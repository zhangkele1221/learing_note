

### **乘积量化（PQ）矩阵转换过程示例**

以下通过一个具体的4×4矩阵分解，逐步演示PQ的整个压缩过程，包括子空间划分、聚类、编码生成及数据重建。

---

### **1. 原始矩阵与子空间划分**

**原始矩阵（4个4维向量）：**
```
[
  [1.2, 3.4, 5.6, 7.8],
  [0.9, 2.8, 6.1, 8.0],
  [1.5, 3.0, 5.0, 7.5],
  [1.0, 3.2, 5.8, 7.9]
]
```

**子空间划分（分解为2个2维子空间）：**
- **子空间1（前2维）：**
  ```
  [
    [1.2, 3.4],
    [0.9, 2.8],
    [1.5, 3.0],
    [1.0, 3.2]
  ]
  ```
  
- **子空间2（后2维）：**
  ```
  [
    [5.6, 7.8],
    [6.1, 8.0],
    [5.0, 7.5],
    [5.8, 7.9]
  ]
  ```

---

### **2. 子空间聚类（以K=2为例）**

#### **(1) 子空间1聚类**
- **聚类中心（手工设定简化计算）：**
  ```
  [
    [1.0, 3.0],  // 聚类ID=0
    [1.5, 3.0]   // 聚类ID=1
  ]
  ```
  
- **分配聚类ID：**
  | 样本点      | 到中心0距离 | 到中心1距离 | 聚类ID |
  |-------------|------------|------------|--------|
  | [1.2, 3.4] | 0.447      | 0.5        | 0      |
  | [0.9, 2.8] | 0.360      | 0.632      | 0      |
  | [1.5, 3.0] | 0.500      | 0.0        | 1      |
  | [1.0, 3.2] | 0.200      | 0.538      | 0      |

#### **(2) 子空间2聚类**
- **聚类中心（手工设定简化计算）：**
  ```
  [
    [5.5, 7.7],  // 聚类ID=0
    [6.0, 8.0]   // 聚类ID=1
  ]
  ```
  
- **分配聚类ID：**
  | 样本点      | 到中心0距离 | 到中心1距离 | 聚类ID |
  |-------------|------------|------------|--------|
  | [5.6, 7.8] | 0.141      | 0.447      | 0      |
  | [6.1, 8.0] | 0.583      | 0.100      | 1      |
  | [5.0, 7.5] | 0.707      | 1.118      | 0      |
  | [5.8, 7.9] | 0.316      | 0.224      | 0      |

---

### **3. 生成编码矩阵**

根据子空间聚类结果，将每个原始向量替换为对应的子空间聚类ID组合：

```
编码矩阵（4×2整数）：
[
  [0, 0],  # 原始向量1 → 子空间1_ID=0, 子空间2_ID=0
  [0, 1],  # 原始向量2 → (0, 1)
  [1, 0],  # 原始向量3 → (1, 0)
  [0, 0]   # 原始向量4 → (0, 0)
]
```

---

### **4. 压缩后数据存储**

#### **(1) 聚类中心矩阵**
- **子空间1聚类中心：** 2×2浮点数 → 存储4个浮点数
- **子空间2聚类中心：** 2×2浮点数 → 存储4个浮点数
- **总浮点数存储量：** 4 + 4 = 8个浮点数

#### **(2) 编码矩阵**
- 4×2整数 → 存储8个整数（假设每整数1字节）

#### **(3) 存储对比**
| **数据类型**      | **维度** | **存储量**         | **字节（假设浮点数4字节）** |
|--------------------|----------|--------------------|---------------------------|
| 原始矩阵           | 4×4      | 16浮点数           | 64字节                    |
| 聚类中心矩阵       | 2×(2×2)  | 8浮点数            | 32字节                    |
| 编码矩阵           | 4×2      | 8整数（1字节/个） | 8字节                     |
| **总压缩存储量**   |          |                    | **40字节**（32+8）        |

**压缩率：** 40 / 64 = 62.5%（节省37.5%存储空间）

---

### **5. 数据重建示例**

通过编码矩阵和聚类中心矩阵，可以近似重建原始数据：

- **编码[0, 0]：**  
  子空间1聚类中心0 `[1.0, 3.0]` + 子空间2聚类中心0 `[5.5, 7.7]` → 重建向量 `[1.0, 3.0, 5.5, 7.7]`  
  （原向量为 `[1.2, 3.4, 5.6, 7.8]`）

- **编码[0, 1]：**  
  子空间1聚类中心0 `[1.0, 3.0]` + 子空间2聚类中心1 `[6.0, 8.0]` → 重建向量 `[1.0, 3.0, 6.0, 8.0]`  
  （原向量为 `[0.9, 2.8, 6.1, 8.0]`）

---

### **6. 关键步骤总结**

1. **子空间分解**：将高维向量拆分为多个低维子空间。
2. **独立聚类**：对每个子空间进行聚类，生成代表性中心。
3. **编码生成**：用聚类ID组合代替原始向量。
4. **存储优化**：仅需保存聚类中心和编码矩阵，大幅减少存储需求。
5. **快速检索**：通过编码查表计算近似距离，加速搜索过程。

---

### **7. 实际应用中的优化方向**

- **动态子空间划分**：根据数据分布调整子空间维度（如使用OPQ优化旋转矩阵）。
- **多级量化**：结合粗量化和细粒度量化，平衡精度与效率。
- **混合量化**：对重要子空间使用更多聚类中心，提升关键特征保留能力。

具体矩阵示例的逐步演示，可以清晰理解PQ如何将高维数据压缩为低维编码，同时保留关键特征以支持高效检索。
